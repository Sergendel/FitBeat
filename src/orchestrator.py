import logging
from dotenv import load_dotenv
from prompt_engineer import PromptEngineer
from llm_executor import LLMExecutor
from output_parser import OutputParser
from track_downloader import TrackDownloader
from extract.extract_file import ExtractFile
from filtering_utils import filter_tracks_by_audio_params
from user_prompt_utils import parse_user_prompt_to_dataframe
from RAG_semantic_refiner import RAGSemanticRefiner
from playlist_summary import summarize_results
from user_prompt_utils import prompt_to_audio_params
load_dotenv()


class Orchestrator:
    def __init__(self):
        self.semantic_refiner = RAGSemanticRefiner()
        self.prompt_engineer = PromptEngineer()
        self.llm_executor = LLMExecutor()
        self.parser = OutputParser()
        self.downloader = TrackDownloader()
        self.dataset = ExtractFile().load_data()
        self.filter_tracks_by_audio_params = filter_tracks_by_audio_params
        self.summarize_results = summarize_results
        self.prompt_to_audio_params = prompt_to_audio_params

        # Action mapping
        self.action_mapping = {
            "Analyze": self.prompt_to_audio_params,
            "Filter": self.filter_tracks_by_audio_params,
            "Refine": self.semantic_refiner.refine_tracks_with_rag,
            "Retrieve_and_Convert": self.downloader.retrieve_and_convert,
            "Summarize": self.summarize_results
        }


    def execute_actions(self, actions_list, user_prompt, num_tracks=10):
        """
            Executes a structured list of actions generated by the LLM-based planning workflow.

            This method orchestrates the end-to-end execution of structured actions derived from a user's request.

            Supported Actions Explicitly:
                - "Analyze": Converts user's prompt into numeric audio parameters.
                - "Filter": Filters tracks based on numeric audio parameters.
                - "Refine": Performs semantic refinement using lyrics and semantic context (RAG).
                - "Retrieve_and_Convert": Downloads tracks from YouTube and converts them to MP3.
                - "Summarize": Summarizes and displays the final playlist results.

            Parameters:
                actions_list (list of str):
                    A structured,ordered list of actions to perform.

                user_prompt (str):
                    The user's original prompt.

                num_tracks (int, optional, default=10):
                    Maximum number of tracks.

            Returns:
                None:
        """

        params = folder_name = tracks = None

        for i_a, action in enumerate(actions_list):
            print(f"{i_a+1}. {action}")

            action_method = self.action_mapping.get(action)
            if not action_method:
                print(f"❌ Error: Unknown action '{action}'.")
                return

            # Explicitly invoke the action method with appropriate parameters:
            if action == "Analyze":
                params, folder_name = action_method(user_prompt)

            elif action == "Filter":
                if params is None:
                    print("❌ Error: 'Analyze' step missing.")
                    return
                tracks = action_method(self.dataset,params, folder_name, num_tracks)

            elif action == "Refine":
                if tracks is None or tracks.empty:
                    print("❌ Error: No tracks to refine.")
                    return
                tracks, folder_name = action_method(user_prompt, tracks, folder_name)

            elif action == "Retrieve_and_Convert":
                if tracks is None:
                    tracks = parse_user_prompt_to_dataframe(user_prompt)
                    folder_name = "user_provided_tracks"
                    if tracks.empty:
                        print("❌ Error: No valid tracks explicitly provided by user.")
                        return
                action_method(tracks, folder_name)

            elif action == "Summarize":
                if tracks is None or tracks.empty:
                    print("❌ Error: No tracks to summarize.")
                    return
                action_method(tracks)

        print("\n✅ All actions executed explicitly and successfully!")


    def run_planning_agent(self, user_prompt, num_tracks=10):
        """
            Runs the complete FitBeat action-planning workflow based on a user-provided prompt.

            This method orchestrates three main steps:

                1. **Planning (Textual)**: Uses an LLM to generate a clear, human-readable textual plan of actions.

                2. **Structuring Actions**: Converts the textual plan into structured JSON actions (e.g., Analyze, Filter, Refine, Retrieve_and_Convert, Summarize).

                3. **Executing Actions**: Executes each structured action sequentially, ensuring robust handling of each step's dependencies.

            Parameters:
                user_prompt (str):
                    The user's description requesting music recommendations, or a direct instruction for track retrieval.

                num_tracks (int, optional, default=10):
                    Specifies the maximum number of tracks.

            Returns:
                None:
            """

        print(f'\n# Step 1: Analyzing user prompt "{user_prompt}". Generating explicit plan of actions...')
        planning_prompt = self.prompt_engineer.construct_planning_prompt(user_prompt)
        messages_plan = planning_prompt.format_messages(user_prompt=user_prompt)
        explicit_plan_text = self.llm_executor.execute(messages_plan)

        if explicit_plan_text is None:
            raise ValueError("LLM returned None or invalid response during planning step.")

        print("Plan of actions:\n", explicit_plan_text)

        print("\n# Step 2: Converting plan to structured actions...")
        structuring_prompt = self.prompt_engineer.construct_action_structuring_prompt(explicit_plan_text)
        messages_structured = structuring_prompt.format_messages(explicit_plan=explicit_plan_text)
        structured_actions_json = self.llm_executor.execute(messages_structured)

        if structured_actions_json is None or "actions" not in structured_actions_json:
            raise ValueError("LLM returned None or invalid response during structuring actions step.")

        actions_list = structured_actions_json["actions"]
        print("Structured Actions:\n", structured_actions_json)

        print("\n\n# Step 3: Executing actions explicitly...")
        self.execute_actions(actions_list, user_prompt, num_tracks)



# Example Usage
if __name__ == "__main__":
    orchestrator = Orchestrator()

    # Scenario 1: Analyze → Filter → Retrieve_and_Convert → Summarize
    #user_prompt = "music for romantic date"

    # Scenario2: Analyze → Filter → Refine → Retrieve_and_Convert → Summarize
    user_prompt = "playlist for romantic date, tracks with deeply meaningful and romantic lyrics"


    # # Scenario 3:
    # user_prompt = (
    #     "I already have a list of specific songs:\n"
    #     "- The Weeknd - Blinding Lights\n"
    #     "- Eminem - Lose Yourself\n"
    #     "- Coldplay - Adventure of a Lifetime\n\n"
    #     "Just download these exact songs from YouTube, convert them to mp3, "
    #     "and summarize the resulting playlist. No additional analysis or recommendations are needed."
    # )

    orchestrator.run_planning_agent(user_prompt, num_tracks=10)









# # planning, test different scenarios
    # user_prompt = (
    #     "I already have a list of songs. I want playlist with similar, but other, songs "
    #     "Can you do it for me ? I just need track names, not the playable files"
    # )  # good!
    # orchestrator.run_planning_agent(user_prompt, num_tracks=20)



    # # test memory:
    # user_prompt_1 = "music tracks suitable for dancing"
    # orchestrator.run_planning_agent(user_prompt_1, num_tracks=10)
    #
    # # Second prompt explicitly tests memory explicitly
    # user_prompt_2 = "Now give me something slower and more relaxing."
    # orchestrator.run_planning_agent(user_prompt_2, num_tracks=10)



    # user_prompt = (
    #     "I already have a list of songs. "
    #     "Can you just find these exact tracks on YouTube, download and convert them to mp3, "
    #     "and then summarize the results for me?"
    # )

    # user_prompt = (
    #     "I already have a list of songs. "
    #     "Can you prepare a payable playlist with these songs for me  ?"
    # )  # tries to find common featires and creates new playlist

    # user_prompt = (
    #     "I already have a list of specific songs. "
    #     "Just download these exact songs from YouTube, convert them to mp3, and summarize the resulting playlist. "
    #     "No additional analysis or recommendations are needed."
    # )  # works but too simple

    # user_prompt = (
    #     "I already have a list of songs. "
    #     "Can you prepare a payable playlist with these songs for me  ?"
    #     "No additional analysis or recommendations are needed."
    # )  # GOOD

    # user_prompt = (
    #     "I already have a list of songs. I want playlist with similar, but other, songs "
    #     "Can you do it for me ?"
    # )  # good!

    # user_prompt = (
    #     "I already have a list of songs. I want playlist with similar, but other, songs "
    #     "Can you do it for me ? I just need track names, not the playable files"
    # )  # good!
    #
    # user_prompt = "music tracks suitable for studying for exams"
